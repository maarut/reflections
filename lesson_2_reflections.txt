-------------------------------------------------------------------------------
What happens when you initialize a repository? Why do you need to do it?
-------------------------------------------------------------------------------

When a repository is initialised, all that happens is that the metadata
structures are created. They are not populated with any data until the first
commit. This needs to happen first, so that git knows that this is a directory
that the user intends to track the revision history of.

-------------------------------------------------------------------------------
How is the staging area different from the working directory and the
repository? What value do you think it offers?
-------------------------------------------------------------------------------

The staging area is a place to hold changes right before a commit is made. The
working directory is an up to the second reflection on what you are working on
whether the files or changes have been added to version control or not. The
staging area is valuable because it allows the user to double check that they
are committing only the changes that they need to before actually committing
to the repository.

-------------------------------------------------------------------------------
How can you use the staging area to make sure you have one commit per logical
change?
-------------------------------------------------------------------------------

The staging area holds only the changes that you wish to commit. You can
perform a diff against the staging area and the repository before committing
to ensure that all of the changes being committed are part of one logical
change.

-------------------------------------------------------------------------------
What are some situations when branches would be helpful in keeping your history
organized? How would branches help?
-------------------------------------------------------------------------------

Branches are useful when trying new things with the codebase that are not yet
ready to add in to the main line. This could be an experimental feature, for 
example, or a major refactoring. Making changes to the master branch could then
be reserved for bug fix changes, or items that deserve to remain in the main
codebase (for example, additional or updated documentation), and the new branch
could show the evolution of the experimental feature. 
